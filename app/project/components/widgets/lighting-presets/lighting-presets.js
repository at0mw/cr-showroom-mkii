/**
 * Copyright (C) 2023 to the present, Crestron Electronics, Inc.
 * All rights reserved.
 * No part of this software may be reproduced in any form, machine
 * or natural, without the express written consent of Crestron Electronics.
 * Use of this source code is subject to the terms of the Crestron Software License Agreement 
 * under which you licensed this source code.  
 *
 * This code was automatically generated by Crestron's code generation tool.
*/
/*jslint es6 */
/*global serviceModule, CrComLib */

const lightingPresetsInstanceModule = (id, elementIds) => {
	'use strict';

	// BEGIN::CHANGEAREA - your initialization code for each instance of widget goes here
	// console.log(`lightingPresets-widget lightingPresetsInstanceModule("${id}", [${elementIds}])`);

	// choose one of the below
	// -- id is container element added around template content
	// -- elementIds[0] is the first element found in the template content
	// -- in shell template, elementIds[0] is usually the right choice
	// const instance = document.getElementById(id);
	const instance = document.getElementById(elementIds[0]);

	// Your code for when widget instance removed from DOM here
	const cleanup = () => {
		// console.log(`lightingPresets-widget lightingPresetsInstanceModule cleanup("${id}")`);
	};

	// Your code changing public interface to instance module here
	return {
		id,
		elementIds,
		instance,
		cleanup
	};

	// END::CHANGEAREA
};

const lightingPresetsModule = (() => {
	'use strict';

	// BEGIN::CHANGEAREA - your initialization code for each instance of widget goes here

	const widgetInstances = {};

	/**
     * Initialize Method
     */
	function onInit() {
		//    serviceModule.addEmulatorScenarioNoControlSystem("./app/project/components/widgets/lighting-presets/lighting-presets-emulator.json");
		// Uncomment the below line and comment the above to load the emulator all the time.
		serviceModule.addEmulatorScenario(
			'./app/project/components/widgets/lighting-presets/lighting-presets-emulator.json'
		);
	}

	function onAddition() {
		const listBackButtonElement = document.getElementById(backButtonId);
		const listForwardButtonElement = document.getElementById(forwardButtonId);
		if (!presetManager) {
			presetManager = new DynamicListMenuLogic(htmlIdPrefix, itemsPerPage);
		}

		if (listBackButtonElement) {
			listBackButtonElement.addEventListener('click', prevPage);
		}

		if (listForwardButtonElement) {
			listForwardButtonElement.addEventListener('click', nextPage);
		}

		const addPresetButton = document.getElementById(addButtonId);
		if (addPresetButton) {
			addPresetButton.addEventListener('click', addPreset);
		}

		const createPresetButton = document.getElementById(createPresetButtonId);
		if (createPresetButton) {
			createPresetButton.addEventListener('click', createPreset);
		}
	}

	function nextPage() {
		if (presetManager) {
			presetManager.moveForwardPage();
		}
	}

	function prevPage() {
		if (presetManager) {
			presetManager.moveBackwardPage();
		}
	}

	function addPreset() {
		console.log('Add Preset');
		const addPresetOverlay = document.getElementById('menu-button-overlay');
		addPresetOverlay.style.display = 'flex';
	}

	function createPreset() {
		console.log('Creating Preset');
		const addPresetOverlay = document.getElementById('menu-button-overlay');
		addPresetOverlay.style.display = 'none';

		const textInput = document.getElementById('label-input');
		const inputLabel = textInput.value;
		textInput.value = '';

		let createPresetMessage = {
			label: inputLabel
		};
		const jsonCreatePresetMessageString = JSON.stringify(createPresetMessage);

		sendSignal.sendSerialSignal('4', jsonCreatePresetMessageString);
	}

	const backButtonId = 'lighting-back-button';
	const forwardButtonId = 'lighting-forward-button';
	const addButtonId = 'lighting-add-button';
	const createPresetButtonId = 'lighting-create-button';
	const htmlIdPrefix = 'lighting';
	const itemsPerPage = 5;
	let presetManager;

	function createPresets(presetsConfig) {
		if (!presetManager) {
			presetManager = new DynamicListMenuLogic(htmlIdPrefix, itemsPerPage);
		}
		presetManager.createDynamicPresets(presetsConfig);
		presetManager.onPresetSelected('presetSelected', handlePresetSelected);
		presetManager.onPresetSelected('presetReordered', handlePresetReorder);
		presetManager.onPresetSelected('presetDeleted', handlePresetDeleted);
	}

	const presetSelectEnum = 1;
	const presetDeleteEnum = 2;
	function handlePresetSelected(event) {
		const presetId = event.detail.presetId;
		console.log('Preset Selected :: Preset Id: ', presetId);
		let jsonSelectMessage = {
			id: presetId,
			action: presetSelectEnum
		};
		const jsonSelectMessageString = JSON.stringify(jsonSelectMessage);

		sendSignal.sendSerialSignal('5', jsonSelectMessageString);
	}

	function handlePresetDeleted(event) {
		const presetId = event.detail.presetId;
		console.log('Preset Deleted :: Preset Id: ', presetId);
		let jsonDeleteMessage = {
			id: presetId,
			action: presetDeleteEnum
		};
		const jsonDeleteMessageString = JSON.stringify(jsonDeleteMessage);

		sendSignal.sendSerialSignal('5', jsonDeleteMessageString);
	}

	function handlePresetReorder(event) {
		const presetId = event.detail.presetId;
		const newOrder = event.detail.newOrder;
		console.log('Preset Reordered :: Preset Id : ', presetId, ' New Order : ', newOrder);
		let jsonReorderMessage = {
			id: presetId,
			neworder: newOrder
		};
		const jsonReorderMessageString = JSON.stringify(jsonReorderMessage);

		sendSignal.sendSerialSignal('3', jsonReorderMessageString);
	}

	function isValidShadePresetConfig(obj) {
		return (
			typeof obj === 'object' &&
			obj !== null &&
			'id' in obj &&
			'label' in obj &&
			'order' in obj &&
			typeof obj.id === 'number' &&
			typeof obj.label === 'string' &&
			typeof obj.order === 'number'
		);
	}

	function parsePresetConfigJsonString(presetConfigJson) {
		console.log(
			'Feedback CrComLib :::: Shade Control ::: Receiving Preset Config Feedback :: Value: ',
			presetConfigJson
		);
		if (presetConfigJson && presetConfigJson !== '') {
			try {
				const parsedObjects = JSON.parse(presetConfigJson);

				if (Array.isArray(parsedObjects) && parsedObjects.every(isValidShadePresetConfig)) {
					createPresets(parsedObjects);
				} else {
					console.error('Parsed objects do not match the expected structure.');
				}
			} catch (error) {
				console.error('Error parsing input:', error);
			}
		}
	}

	// === Subscribe to Shade Slider Preset Feedback and Handle ===
	const shadePresetConfigSubscription = CrComLib.subscribeState('s', serialJoins.LightingPresetsConfig, (value) => {
		console.log('Feedback CrComLib :::: String Join ', serialJoins.LightingPresetsConfig, ' ::: Value :: ', value);
		parsePresetConfigJsonString(value);
	});

	/**
     * private method for widget class creation
     */
	let loadedSubId = CrComLib.subscribeState('o', 'ch5-import-htmlsnippet:lightingPresets-import-widget', (value) => {
		if (value['loaded']) {
			setTimeout(() => {
				CrComLib.unsubscribeState('o', 'ch5-import-htmlsnippet:lightingPresets-import-page', loadedSubId);
				loadedSubId = '';
			});
		}
	});

	/**
     * private method for widget instance addition and removal
     */
	CrComLib.subscribeState('o', 'ch5-template:lighting-presets-widget', (value) => {
		if (value['loaded'] !== undefined && value['id'] !== undefined) {
			if (value.loaded) {
				onInit();
				onAddition();
				widgetInstances[value.id] = lightingPresetsInstanceModule(value.id, value['elementIds']);
			} else {
				const removedInstance = widgetInstances[value.id];
				if (removedInstance) {
					removedInstance.cleanup();
					delete widgetInstances[value.id];
				}
			}
		}
	});
	/**
     * All public method and properties are exported here
     */
	return {
		widgetInstances
	};

	// END::CHANGEAREA
})();
