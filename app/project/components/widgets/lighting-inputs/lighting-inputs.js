/**
 * Copyright (C) 2023 to the present, Crestron Electronics, Inc.
 * All rights reserved.
 * No part of this software may be reproduced in any form, machine
 * or natural, without the express written consent of Crestron Electronics.
 * Use of this source code is subject to the terms of the Crestron Software License Agreement 
 * under which you licensed this source code.  
 *
 * This code was automatically generated by Crestron's code generation tool.
*/
/*jslint es6 */
/*global serviceModule, CrComLib */

const lightingInputsInstanceModule = (id, elementIds) => {
    'use strict';    

    // BEGIN::CHANGEAREA - your initialization code for each instance of widget goes here  
    // console.log(`lightingInputs-widget lightingInputsInstanceModule("${id}", [${elementIds}])`);

    // choose one of the below 
    // -- id is container element added around template content
    // -- elementIds[0] is the first element found in the template content
    // -- in shell template, elementIds[0] is usually the right choice
    // const instance = document.getElementById(id);
    const instance = document.getElementById(elementIds[0]);

    // Your code for when widget instance removed from DOM here
    const cleanup = () => {
        // console.log(`lightingInputs-widget lightingInputsInstanceModule cleanup("${id}")`);
    };

    // Your code changing public interface to instance module here 
    return {
        id,
        elementIds,
        instance,
        cleanup
    };

    // END::CHANGEAREA  
} 

const lightingInputsModule = (() => {
    'use strict';

    // BEGIN::CHANGEAREA - your initialization code for each instance of widget goes here  
   
    const widgetInstances = {};

    /**
     * Initialize Method
     */
    function onInit() {
       serviceModule.addEmulatorScenarioNoControlSystem("./app/project/components/widgets/lighting-inputs/lighting-inputs-emulator.json");
       // Uncomment the below line and comment the above to load the emulator all the time.
       // serviceModule.addEmulatorScenario("./app/project/components/widgets/lighting-inputs/lighting-inputs-emulator.json");
    }

    function onAddition() {
        window.addEventListener('resize', handleShowSliderAutoInput);
        const slider_input = document.getElementById('brightness-input');
        if (slider_input) {
            slider_input.addEventListener('input', handleShowSliderUserInput);
            slider_input.addEventListener('change', sendBrightnessUpdate);
        }
    }

    function sendBrightnessUpdate(event) {
		const inputValue = event.target.value;
		const parsedValue = parseInt(inputValue, 10);
		sendSignal.sendAnalogSignal('1', parsedValue);
	}

    function handleShowSliderAutoInput() {
		showSliderValue(false);
	}

	function handleShowSliderUserInput() {
		showSliderValue(true);
	}

	function showSliderValue(showThumb) {
        // TODO Only one instance of this widget is therefore useable, can replace with context?
		const sliderInput = document.getElementById('brightness-input');
		const sliderThumb = document.getElementById('brightness-thumb');
		const sliderLine = document.getElementById('brightness-line');

		if (sliderInput && sliderThumb && sliderLine) {
			if (showThumb) {
				revealThumbMovementVisuals(sliderThumb);
			}
			updateSliderAndThumbPosition(sliderInput, sliderThumb, sliderLine);
		}
	}

	let thumbDisappearTimeout;
	function revealThumbMovementVisuals(sliderThumb) {
		let thumbText = sliderThumb.querySelector('.thumb-text');
		thumbText.style.opacity = 1;
		if (thumbDisappearTimeout) {
			clearTimeout(thumbDisappearTimeout);
		}
		sliderThumb.classList.add('active');
		sliderThumb.style.opacity = '1';

		thumbDisappearTimeout = setTimeout(() => {
			thumbText.style.opacity = 0;
			sliderThumb.classList.remove('active');
		}, 1500);
	}

	function updateSliderAndThumbPosition(sliderInput, sliderThumb, sliderLine) {
		let thumbText = sliderThumb.querySelector('.thumb-text');
		thumbText.innerHTML = sliderInput.value;
		const bulletPosition = sliderInput.value / sliderInput.max,
			space = sliderInput.offsetWidth;

		sliderThumb.style.left = bulletPosition * space + 'px';
		sliderLine.style.width = (sliderInput.value / sliderInput.max * 100) + '%';
	}

    /**
     * private method for widget class creation
     */
    let loadedSubId = CrComLib.subscribeState('o', 'ch5-import-htmlsnippet:lightingInputs-import-widget', (value) => {
        if (value['loaded']) {
            onInit();
            setTimeout(() => {
                CrComLib.unsubscribeState('o', 'ch5-import-htmlsnippet:lightingInputs-import-page', loadedSubId);
                loadedSubId = '';
            });
        }
    });

    /**
     * private method for widget instance addition and removal
     */
    CrComLib.subscribeState('o', 'ch5-template:lighting-inputs-widget', (value) => {
        if (value['loaded'] !== undefined && value['id'] !== undefined) {
            if (value.loaded) {
                onAddition();
                widgetInstances[value.id] = lightingInputsInstanceModule(value.id, value['elementIds']);
            }
            else {
                const removedInstance = widgetInstances[value.id];
                if (removedInstance) {
                    removedInstance.cleanup();
                    delete widgetInstances[value.id];
                }
            }
        }
    });
    /**
     * All public method and properties are exported here
     */
    return {
        widgetInstances
    };

    // END::CHANGEAREA   

})();