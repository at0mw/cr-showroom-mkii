/**
 * Copyright (C) 2023 to the present, Crestron Electronics, Inc.
 * All rights reserved.
 * No part of this software may be reproduced in any form, machine
 * or natural, without the express written consent of Crestron Electronics.
 * Use of this source code is subject to the terms of the Crestron Software License Agreement 
 * under which you licensed this source code.  
 *
 * This code was automatically generated by Crestron's code generation tool.
*/
/*jslint es6 */
/*global serviceModule, CrComLib */

const shadePresetsInstanceModule = (id, elementIds) => {
    'use strict';    

    // BEGIN::CHANGEAREA - your initialization code for each instance of widget goes here  
    // console.log(`shadePresets-widget shadePresetsInstanceModule("${id}", [${elementIds}])`);

    // choose one of the below 
    // -- id is container element added around template content
    // -- elementIds[0] is the first element found in the template content
    // -- in shell template, elementIds[0] is usually the right choice
    // const instance = document.getElementById(id);
    const instance = document.getElementById(elementIds[0]);

    // Your code for when widget instance removed from DOM here
    const cleanup = () => {
        // console.log(`shadePresets-widget shadePresetsInstanceModule cleanup("${id}")`);
    };

    // Your code changing public interface to instance module here 
    return {
        id,
        elementIds,
        instance,
        cleanup
    };

    // END::CHANGEAREA  
} 

const shadePresetsModule = (() => {
    'use strict';

    // BEGIN::CHANGEAREA - your initialization code for each instance of widget goes here  
   
    const widgetInstances = {};

    /**
     * Initialize Method
     */
    function onInit() {
    //    serviceModule.addEmulatorScenarioNoControlSystem("./app/project/components/widgets/shade-surface/shade-presets/shade-presets-emulator.json");
       // Uncomment the below line and comment the above to load the emulator all the time.
       serviceModule.addEmulatorScenario("./app/project/components/widgets/shade-surface/shade-presets/shade-presets-emulator.json");
    }

    function onAddition() {
		const listBackButtonElement = document.getElementById(backButtonId);
		const listForwardButtonElement = document.getElementById(forwardButtonId);
		if (!presetManager) {
			presetManager = new DynamicListMenuLogic(htmlIdPrefix, itemsPerPage);
		}

		if (listBackButtonElement) {
			listBackButtonElement.addEventListener('click', prevPage);
		}

		if (listForwardButtonElement) {
			listForwardButtonElement.addEventListener('click', nextPage);
		}

		const addPresetButton = document.getElementById(addButtonId);
		if (addPresetButton) {
			addPresetButton.addEventListener('click', addPreset);
		}

		const createPresetButton = document.getElementById(createPresetButtonId);
		if (createPresetButton) {
			createPresetButton.addEventListener('click', createPreset);
		}
	}

	function nextPage() {
		if (presetManager) {
			presetManager.moveForwardPage();
		}
	}

	function prevPage() {
		if (presetManager) {
			presetManager.moveBackwardPage();
		}
	}

	function addPreset() {
		console.log('Add Preset');
		const addPresetOverlay = document.getElementById('menu-button-overlay');
		addPresetOverlay.style.display = 'flex';
	}

	function createPreset() {
		console.log('Creating Preset');
		const addPresetOverlay = document.getElementById('menu-button-overlay');
		addPresetOverlay.style.display = 'none';

		const textInput = document.getElementById('label-input');
		const inputLabel = textInput.value;
		textInput.value = '';

		let createPresetMessage = {
			label: inputLabel
		};
		const jsonCreatePresetMessageString = JSON.stringify(createPresetMessage);

		sendSignal.sendSerialSignal(serialJoins.ShadeControlCreatePreset, jsonCreatePresetMessageString);
	}

	const backButtonId = 'shade-back-button';
	const forwardButtonId = 'shade-forward-button';
	const addButtonId = 'shade-add-button';
	const createPresetButtonId = 'shade-create-button';
	const htmlIdPrefix = 'shade';
	const itemsPerPage = 5;
	let presetManager;

	function createPresets(presetsConfig) {
		if (!presetManager) {
			presetManager = new DynamicListMenuLogic(htmlIdPrefix, itemsPerPage);
		}
		presetManager.createDynamicPresets(presetsConfig);
		presetManager.onPresetSelected('presetSelected', handlePresetSelected);
		presetManager.onPresetSelected('presetReordered', handlePresetReorder);
		presetManager.onPresetSelected('presetDeleted', handlePresetDeleted);
	}

	const presetSelectEnum = 1;
	const presetDeleteEnum = 2;
	function handlePresetSelected(event) {
		const presetId = event.detail.presetId;
		console.log('Preset Selected :: Preset Id: ', presetId);
		let jsonSelectMessage = {
			id: presetId,
			action: presetSelectEnum
		};
		const jsonSelectMessageString = JSON.stringify(jsonSelectMessage);

		sendSignal.sendSerialSignal(serialJoins.ShadeControlPresetSelect, jsonSelectMessageString);
	}

	function handlePresetDeleted(event) {
		const presetId = event.detail.presetId;
		console.log('Preset Deleted :: Preset Id: ', presetId);
		let jsonDeleteMessage = {
			id: presetId,
			action: presetDeleteEnum
		};
		const jsonDeleteMessageString = JSON.stringify(jsonDeleteMessage);

		sendSignal.sendSerialSignal(serialJoins.ShadeControlPresetSelect, jsonDeleteMessageString);
	}

	function handlePresetReorder(event) {
		const presetId = event.detail.presetId;
		const newOrder = event.detail.newOrder;
		console.log('Preset Reordered :: Preset Id : ', presetId, ' New Order : ', newOrder);
		let jsonReorderMessage = {
			id: presetId,
			neworder: newOrder
		};
		const jsonReorderMessageString = JSON.stringify(jsonReorderMessage);

		sendSignal.sendSerialSignal(serialJoins.ShadeControlPresetReorder, jsonReorderMessageString);
	}

	function isValidShadePresetConfig(obj) {
		return (
			typeof obj === 'object' &&
			obj !== null &&
			'id' in obj &&
			'label' in obj &&
			'order' in obj &&
			typeof obj.id === 'number' &&
			typeof obj.label === 'string' &&
			typeof obj.order === 'number'
		);
	}

	function parsePresetConfigJsonString(presetConfigJson) {
		console.log(
			'Feedback CrComLib :::: Shade Control ::: Receiving Preset Config Feedback :: Value: ',
			presetConfigJson
		);
		if (presetConfigJson && presetConfigJson !== '') {
			try {
				const parsedObjects = JSON.parse(presetConfigJson);

				if (Array.isArray(parsedObjects) && parsedObjects.every(isValidShadePresetConfig)) {
					createPresets(parsedObjects);
				} else {
					console.error('Parsed objects do not match the expected structure.');
				}
			} catch (error) {
				console.error('Error parsing input:', error);
			}
		}
	}

	// === Subscribe to Shade Slider Preset Feedback and Handle ===
	const shadePresetConfigSubscription = CrComLib.subscribeState('s', serialJoins.ShadeControlPresetConfig, (value) => {
		console.log('Feedback CrComLib :::: String Join ', serialJoins.ShadeControlPresetConfig, ' ::: Value :: ', value);
		parsePresetConfigJsonString(value);
	});

    /**
     * private method for widget class creation
     */
    let loadedSubId = CrComLib.subscribeState('o', 'ch5-import-htmlsnippet:shadePresets-import-widget', (value) => {
        if (value['loaded']) {
            setTimeout(() => {
                CrComLib.unsubscribeState('o', 'ch5-import-htmlsnippet:shadePresets-import-page', loadedSubId);
                loadedSubId = '';
            });
        }
    });

    /**
     * private method for widget instance addition and removal
     */
    CrComLib.subscribeState('o', 'ch5-template:shade-presets-widget', (value) => {
        if (value['loaded'] !== undefined && value['id'] !== undefined) {
            if (value.loaded) {
                onInit();
                onAddition();
                widgetInstances[value.id] = shadePresetsInstanceModule(value.id, value['elementIds']);
            }
            else {
                const removedInstance = widgetInstances[value.id];
                if (removedInstance) {
                    removedInstance.cleanup();
                    delete widgetInstances[value.id];
                }
            }
        }
    });
    /**
     * All public method and properties are exported here
     */
    return {
        widgetInstances
    };

    // END::CHANGEAREA   

})();